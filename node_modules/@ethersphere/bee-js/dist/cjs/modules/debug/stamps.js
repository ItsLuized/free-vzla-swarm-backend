"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.diluteBatch = exports.topUpBatch = exports.createPostageBatch = exports.getPostageBatchBuckets = exports.getPostageBatch = exports.getAllPostageBatches = void 0;
const http_1 = require("../../utils/http");
const STAMPS_ENDPOINT = 'stamps';
function getAllPostageBatches(ky) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, http_1.http)(ky, {
            method: 'get',
            path: `${STAMPS_ENDPOINT}`,
            responseType: 'json',
        });
        return response.data.stamps;
    });
}
exports.getAllPostageBatches = getAllPostageBatches;
function getPostageBatch(ky, postageBatchId) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, http_1.http)(ky, {
            method: 'get',
            path: `${STAMPS_ENDPOINT}/${postageBatchId}`,
            responseType: 'json',
        });
        return response.data;
    });
}
exports.getPostageBatch = getPostageBatch;
function getPostageBatchBuckets(ky, postageBatchId) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, http_1.http)(ky, {
            method: 'get',
            path: `${STAMPS_ENDPOINT}/${postageBatchId}/buckets`,
            responseType: 'json',
        });
        return response.data;
    });
}
exports.getPostageBatchBuckets = getPostageBatchBuckets;
function createPostageBatch(ky, amount, depth, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = {};
        if (options === null || options === void 0 ? void 0 : options.gasPrice) {
            headers['gas-price'] = options.gasPrice.toString();
        }
        if ((options === null || options === void 0 ? void 0 : options.immutableFlag) !== undefined) {
            headers.immutable = String(options.immutableFlag);
        }
        const response = yield (0, http_1.http)(ky, {
            method: 'post',
            path: `${STAMPS_ENDPOINT}/${amount}/${depth}`,
            responseType: 'json',
            searchParams: { label: options === null || options === void 0 ? void 0 : options.label },
            headers,
        });
        return response.data.batchID;
    });
}
exports.createPostageBatch = createPostageBatch;
function topUpBatch(ky, id, amount) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, http_1.http)(ky, {
            method: 'patch',
            path: `${STAMPS_ENDPOINT}/topup/${id}/${amount}`,
            responseType: 'json',
        });
        return response.data.batchID;
    });
}
exports.topUpBatch = topUpBatch;
function diluteBatch(ky, id, depth) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, http_1.http)(ky, {
            method: 'patch',
            path: `${STAMPS_ENDPOINT}/dilute/${id}/${depth}`,
            responseType: 'json',
        });
        return response.data.batchID;
    });
}
exports.diluteBatch = diluteBatch;

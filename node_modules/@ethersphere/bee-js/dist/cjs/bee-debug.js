"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BeeDebug = void 0;
const connectivity = __importStar(require("./modules/debug/connectivity"));
const balance = __importStar(require("./modules/debug/balance"));
const chequebook = __importStar(require("./modules/debug/chequebook"));
const settlements = __importStar(require("./modules/debug/settlements"));
const status = __importStar(require("./modules/debug/status"));
const transactions = __importStar(require("./modules/debug/transactions"));
const states = __importStar(require("./modules/debug/states"));
const error_1 = require("./utils/error");
const url_1 = require("./utils/url");
const type_1 = require("./utils/type");
const types_1 = require("./types");
const tag = __importStar(require("./modules/debug/tag"));
const stamps = __importStar(require("./modules/debug/stamps"));
const http_1 = require("./utils/http");
const sleep_1 = require("./utils/sleep");
class BeeDebug {
    constructor(url, options) {
        var _a;
        (0, url_1.assertBeeUrl)(url);
        // Remove last slash if present, as our endpoint strings starts with `/...`
        // which could lead to double slash in URL to which Bee responds with
        // unnecessary redirects.
        this.url = (0, url_1.stripLastSlash)(url);
        const kyOptions = {
            prefixUrl: this.url,
            timeout: (_a = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a !== void 0 ? _a : false,
            retry: options === null || options === void 0 ? void 0 : options.retry,
            fetch: options === null || options === void 0 ? void 0 : options.fetch,
            hooks: {
                beforeRequest: [],
                afterResponse: [],
            },
        };
        if (options === null || options === void 0 ? void 0 : options.defaultHeaders) {
            kyOptions.headers = options.defaultHeaders;
        }
        if (options === null || options === void 0 ? void 0 : options.onRequest) {
            kyOptions.hooks.beforeRequest.push((0, http_1.wrapRequestClosure)(options.onRequest));
        }
        if (options === null || options === void 0 ? void 0 : options.onResponse) {
            kyOptions.hooks.afterResponse.push((0, http_1.wrapResponseClosure)(options.onResponse));
        }
        this.ky = (0, http_1.makeDefaultKy)(kyOptions);
    }
    getNodeAddresses(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return connectivity.getNodeAddresses(this.getKy(options));
        });
    }
    getBlocklist(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return connectivity.getBlocklist(this.getKy(options));
        });
    }
    /**
     * Retrieve tag extended information from Bee node
     *
     * @param tagUid UID or tag object to be retrieved
     * @throws TypeError if tagUid is in not correct format
     *
     * @see [Bee docs - Syncing / Tags](https://docs.ethswarm.org/docs/access-the-swarm/syncing)
     * @see [Bee API reference - `GET /tags/{uid}`](https://docs.ethswarm.org/debug-api/#tag/Tag)
     *
     */
    retrieveExtendedTag(tagUid, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            if ((0, type_1.isTag)(tagUid)) {
                tagUid = tagUid.uid;
            }
            else if (typeof tagUid === 'number') {
                (0, type_1.assertNonNegativeInteger)(tagUid, 'UID');
            }
            else {
                throw new TypeError('tagUid has to be either Tag or a number (UID)!');
            }
            return tag.retrieveExtendedTag(this.getKy(options), tagUid);
        });
    }
    /**
     * Get list of peers for this node
     */
    getPeers(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return connectivity.getPeers(this.getKy(options));
        });
    }
    removePeer(peer, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertAddress)(peer);
            return connectivity.removePeer(this.getKy(options), peer);
        });
    }
    getTopology(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return connectivity.getTopology(this.getKy(options));
        });
    }
    pingPeer(peer, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertAddress)(peer);
            return connectivity.pingPeer(this.getKy(options), peer);
        });
    }
    /*
     * Balance endpoints
     */
    /**
     * Get the balances with all known peers including prepaid services
     */
    getAllBalances(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return balance.getAllBalances(this.getKy(options));
        });
    }
    /**
     * Get the balances with a specific peer including prepaid services
     *
     * @param address Swarm address of peer
     */
    getPeerBalance(address, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertAddress)(address);
            return balance.getPeerBalance(this.getKy(options), address);
        });
    }
    /**
     * Get the past due consumption balances with all known peers
     */
    getPastDueConsumptionBalances(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return balance.getPastDueConsumptionBalances(this.getKy(options));
        });
    }
    /**
     * Get the past due consumption balance with a specific peer
     *
     * @param address Swarm address of peer
     */
    getPastDueConsumptionPeerBalance(address, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertAddress)(address);
            return balance.getPastDueConsumptionPeerBalance(this.getKy(options), address);
        });
    }
    /*
     * Chequebook endpoints
     */
    /**
     * Get the address of the chequebook contract used.
     *
     * **Warning:** The address is returned with 0x prefix unlike all other calls.
     * https://github.com/ethersphere/bee/issues/1443
     */
    getChequebookAddress(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return chequebook.getChequebookAddress(this.getKy(options));
        });
    }
    /**
     * Get the balance of the chequebook
     */
    getChequebookBalance(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return chequebook.getChequebookBalance(this.getKy(options));
        });
    }
    /**
     * Get last cheques for all peers
     */
    getLastCheques(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return chequebook.getLastCheques(this.getKy(options));
        });
    }
    /**
     * Get last cheques for the peer
     *
     * @param address  Swarm address of peer
     */
    getLastChequesForPeer(address, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertAddress)(address);
            return chequebook.getLastChequesForPeer(this.getKy(options), address);
        });
    }
    /**
     * Get last cashout action for the peer
     *
     * @param address  Swarm address of peer
     */
    getLastCashoutAction(address, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertAddress)(address);
            return chequebook.getLastCashoutAction(this.getKy(options), address);
        });
    }
    /**
     * Cashout the last cheque for the peer
     *
     * @param address  Swarm address of peer
     * @param options
     * @param options.gasPrice Gas price for the cashout transaction in WEI
     * @param options.gasLimit Gas limit for the cashout transaction in WEI
     */
    cashoutLastCheque(address, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertCashoutOptions)(options);
            (0, type_1.assertAddress)(address);
            return chequebook.cashoutLastCheque(this.getKy(options), address, options);
        });
    }
    /**
     * Deposit tokens from overlay address into chequebook
     *
     * @param amount  Amount of tokens to deposit (must be positive integer)
     * @param gasPrice Gas Price in WEI for the transaction call
     * @return string  Hash of the transaction
     */
    depositTokens(amount, gasPrice, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertNonNegativeInteger)(amount);
            if (gasPrice) {
                (0, type_1.assertNonNegativeInteger)(gasPrice);
            }
            return chequebook.depositTokens(this.getKy(options), amount, gasPrice);
        });
    }
    /**
     * Withdraw tokens from the chequebook to the overlay address
     *
     * @param amount  Amount of tokens to withdraw (must be positive integer)
     * @param gasPrice Gas Price in WEI for the transaction call
     * @return string  Hash of the transaction
     */
    withdrawTokens(amount, gasPrice, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertNonNegativeInteger)(amount);
            if (gasPrice) {
                (0, type_1.assertNonNegativeInteger)(gasPrice);
            }
            return chequebook.withdrawTokens(this.getKy(options), amount, gasPrice);
        });
    }
    /*
     * Settlements endpoint
     */
    /**
     * Get amount of sent and received from settlements with a peer
     *
     * @param address  Swarm address of peer
     */
    getSettlements(address, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertAddress)(address);
            return settlements.getSettlements(this.getKy(options), address);
        });
    }
    /**
     * Get settlements with all known peers and total amount sent or received
     */
    getAllSettlements(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return settlements.getAllSettlements(this.getKy(options));
        });
    }
    /**
     * Get health of node
     */
    getHealth(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return status.getHealth(this.getKy(options));
        });
    }
    /**
     * Get mode information of node
     */
    getNodeInfo(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return status.getNodeInfo(this.getKy(options));
        });
    }
    /**
     * Connnects to a node and checks if it is a supported Bee version by the bee-js
     *
     * @returns true if the Bee node version is supported
     * @deprecated Use `BeeDebug.isSupportedExactVersion()` instead
     */
    isSupportedVersion(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return status.isSupportedVersion(this.getKy(options));
        });
    }
    /**
     * Connects to a node and checks if its version matches with the one that bee-js supports.
     *
     * Be aware that this is the most strict version check and most probably
     * you will want to use more relaxed API-versions based checks like
     * `BeeDebug.isSupportedApiVersion()`, `BeeDebug.isSupportedMainApiVersion()` or `BeeDebug.isSupportedDebugApiVersion()`
     * based on your use-case.
     *
     * @param options
     */
    isSupportedExactVersion(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return status.isSupportedExactVersion(this.getKy(options));
        });
    }
    /**
     * Connects to a node and checks if its main's API version matches with the one that bee-js supports.
     *
     * This is useful if you are not using `BeeDebug` class (for anything else then this check)
     * and want to make sure about compatibility.
     *
     * @param options
     */
    isSupportedMainApiVersion(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return status.isSupportedMainApiVersion(this.getKy(options));
        });
    }
    /**
     * Connects to a node and checks if its Debug API version matches with the one that bee-js supports.
     *
     * This is useful if you are not using `Bee` class in your application and want to make sure
     * about compatibility.
     *
     * @param options
     */
    isSupportedDebugApiVersion(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return status.isSupportedDebugApiVersion(this.getKy(options));
        });
    }
    /**
     *
     * Connects to a node and checks if its Main and Debug API versions matches with the one that bee-js supports.
     *
     * This should be the main way how to check compatibility for your app and Bee node.
     *
     * @param options
     */
    isSupportedApiVersion(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return status.isSupportedDebugApiVersion(this.getKy(options));
        });
    }
    /**
     * Returns object with all versions specified by the connected Bee node (properties prefixed with `bee*`)
     * and versions that bee-js supports (properties prefixed with `supported*`).
     *
     * @param options
     */
    getVersions(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return status.getVersions(this.getKy(options));
        });
    }
    /**
     * Get reserve state
     */
    getReserveState(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return states.getReserveState(this.getKy(options));
        });
    }
    /**
     * Get chain state
     */
    getChainState(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return states.getChainState(this.getKy(options));
        });
    }
    /**
     * Get wallet balances for xDai and BZZ of the Bee node
     *
     * @param options
     */
    getWalletBalance(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return states.getWalletBalance(this.getKy(options));
        });
    }
    /**
     * Creates new postage batch from the funds that the node has available in its Ethereum account.
     *
     * For better understanding what each parameter means and what are the optimal values please see
     * [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive).
     *
     * **WARNING: THIS CREATES TRANSACTIONS THAT SPENDS MONEY**
     *
     * @param amount Amount that represents the value per chunk, has to be greater or equal zero.
     * @param depth Logarithm of the number of chunks that can be stamped with the batch.
     * @param options Options for creation of postage batch
     * @throws BeeArgumentError when negative amount or depth is specified
     * @throws TypeError if non-integer value is passed to amount or depth
     *
     * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
     * @see [Bee Debug API reference - `POST /stamps`](https://docs.ethswarm.org/debug-api/#tag/Postage-Stamps/paths/~1stamps~1{amount}~1{depth}/post)
     */
    createPostageBatch(amount, depth, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertPostageBatchOptions)(options);
            (0, type_1.assertPositiveInteger)(amount);
            (0, type_1.assertNonNegativeInteger)(depth);
            if (depth < types_1.STAMPS_DEPTH_MIN) {
                throw new error_1.BeeArgumentError(`Depth has to be at least ${types_1.STAMPS_DEPTH_MIN}`, depth);
            }
            if (depth > types_1.STAMPS_DEPTH_MAX) {
                throw new error_1.BeeArgumentError(`Depth has to be at most ${types_1.STAMPS_DEPTH_MAX}`, depth);
            }
            const stamp = yield stamps.createPostageBatch(this.getKy(options), amount, depth, options);
            if ((options === null || options === void 0 ? void 0 : options.waitForUsable) !== false) {
                yield this.waitForUsablePostageStamp(stamp, options === null || options === void 0 ? void 0 : options.waitForUsableTimeout);
            }
            return stamp;
        });
    }
    /**
     * Topup a fresh amount of BZZ to given Postage Batch.
     *
     * For better understanding what each parameter means and what are the optimal values please see
     * [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive).
     *
     * **WARNING: THIS CREATES TRANSACTIONS THAT SPENDS MONEY**
     *
     * @param postageBatchId Batch ID
     * @param amount Amount to be added to the batch
     * @param options Request options
     *
     * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
     * @see [Bee Debug API reference - `PATCH /stamps/topup/${id}/${amount}`](https://docs.ethswarm.org/debug-api/#tag/Postage-Stamps/paths/~1stamps~1topup~1{id}~1{amount}/patch)
     */
    topUpBatch(postageBatchId, amount, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertNonNegativeInteger)(amount, 'Amount');
            (0, type_1.assertBatchId)(postageBatchId);
            yield stamps.topUpBatch(this.getKy(options), postageBatchId, amount);
        });
    }
    /**
     * Dilute given Postage Batch with new depth (that has to be bigger then the original depth), which allows
     * the Postage Batch to be used for more chunks.
     *
     * For better understanding what each parameter means and what are the optimal values please see
     * [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive).
     *
     * **WARNING: THIS CREATES TRANSACTIONS THAT SPENDS MONEY**
     *
     * @param postageBatchId Batch ID
     * @param depth Amount to be added to the batch
     * @param options Request options
     *
     * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
     * @see [Bee Debug API reference - `PATCH /stamps/topup/${id}/${amount}`](https://docs.ethswarm.org/debug-api/#tag/Postage-Stamps/paths/~1stamps~1topup~1{id}~1{amount}/patch)
     */
    diluteBatch(postageBatchId, depth, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertNonNegativeInteger)(depth, 'Depth');
            (0, type_1.assertBatchId)(postageBatchId);
            yield stamps.diluteBatch(this.getKy(options), postageBatchId, depth);
        });
    }
    /**
     * Return details for specific postage batch.
     *
     * @param postageBatchId Batch ID
     *
     * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
     * @see [Bee Debug API reference - `GET /stamps/${id}`](https://docs.ethswarm.org/debug-api/#tag/Postage-Stamps/paths/~1stamps~1{id}/get)
     */
    getPostageBatch(postageBatchId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertBatchId)(postageBatchId);
            return stamps.getPostageBatch(this.getKy(options), postageBatchId);
        });
    }
    /**
     * Return detailed information related to buckets for specific postage batch.
     *
     * @param postageBatchId Batch ID
     *
     * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
     * @see [Bee Debug API reference - `GET /stamps/${id}/buckets`](https://docs.ethswarm.org/debug-api/#tag/Postage-Stamps/paths/~1stamps~1{id}~1buckets/get)
     */
    getPostageBatchBuckets(postageBatchId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertBatchId)(postageBatchId);
            return stamps.getPostageBatchBuckets(this.getKy(options), postageBatchId);
        });
    }
    /**
     * Return all postage batches that has the node available.
     *
     * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
     * @see [Bee Debug API reference - `GET /stamps`](https://docs.ethswarm.org/debug-api/#tag/Postage-Stamps/paths/~1stamps/get)
     */
    getAllPostageBatch(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return stamps.getAllPostageBatches(this.getKy(options));
        });
    }
    /**
     * Return lists of all current pending transactions that the Bee made
     */
    getAllPendingTransactions(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            return transactions.getAllTransactions(this.getKy(options));
        });
    }
    /**
     * Return transaction information for specific transaction
     * @param transactionHash
     */
    getPendingTransaction(transactionHash, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertTransactionHash)(transactionHash);
            return transactions.getTransaction(this.getKy(options), transactionHash);
        });
    }
    /**
     * Rebroadcast already created transaction.
     * This is mainly needed when your transaction fall off mempool from other reason is not incorporated into block.
     *
     * @param transactionHash
     */
    rebroadcastPendingTransaction(transactionHash, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertTransactionHash)(transactionHash);
            return transactions.rebroadcastTransaction(this.getKy(options), transactionHash);
        });
    }
    /**
     * Cancel currently pending transaction
     * @param transactionHash
     * @param gasPrice
     */
    cancelPendingTransaction(transactionHash, gasPrice, options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, type_1.assertRequestOptions)(options);
            (0, type_1.assertTransactionHash)(transactionHash);
            if (gasPrice) {
                (0, type_1.assertNonNegativeInteger)(gasPrice);
            }
            return transactions.cancelTransaction(this.getKy(options), transactionHash, gasPrice);
        });
    }
    waitForUsablePostageStamp(id, timeout = 120000) {
        return __awaiter(this, void 0, void 0, function* () {
            const TIME_STEP = 1500;
            for (let time = 0; time < timeout; time += TIME_STEP) {
                const stamp = yield this.getPostageBatch(id);
                if (stamp.usable) {
                    return;
                }
                yield (0, sleep_1.sleep)(TIME_STEP);
            }
            throw new error_1.BeeError('Timeout on waiting for postage stamp to become usable');
        });
    }
    getKy(options) {
        if (!options) {
            return this.ky;
        }
        return this.ky.extend(options);
    }
}
exports.BeeDebug = BeeDebug;
